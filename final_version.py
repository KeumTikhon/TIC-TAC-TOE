"""
Изначальная формулировка:
    Вам дана конфигурация частично заполненного поля игры крестики-нолики.
    Необходимо, чтобы Ваше приложение сделало следующий наиболее разумный ход.

Техническое задание:
    Игровое поле (3x3) для крестиков-ноликов будет задаваться в консоли,
    в виде трех строчек, в каждой из которых три символа разделенные пробелами.
    ('x'- крестики; 'o'- нолики; '~'- пустая ячейка (все символы в английской раскладке))

Примеры:
    1) ~ ~ ~  2) x o x
       ~ ~ ~     o x ~
       ~ ~ ~     ~ ~ o

Программа не будет работать коректно, если поле задано неправильно или на поле уже есть победитель.

Программа должна печатать наилучший ход для КРЕСТИКОВ по заданному раскладу игры 		        x ~ o  выдаст x ~ o
								     		                                        ( например: x o ~   ===>  x o ~  )
									        		                                            ~ ~ ~         x ~ ~

Если же форма задана верно, но такого расклада не может быть, то программа выведет: "Такого расклада не может быть."
"""

win_line=[(0,1,2),(3,4,5),(6,7,8),(0,3,6),(1,4,7),(2,5,8),(0,4,8),(2,4,6)] #все варианты победных линий
corner=[(6,3,0,1,2),(0,1,2,5,8),(2,5,8,7,6),(8,7,6,3,0)] #углы поля
def defence_attack(start_board):
    #если есть линия в которой 2 крестика/нолика, то закончить/перекрыть линию
    # приоритет поставить третий крестик больше чем перекрыть линию ноликов
    for i in range(8): #8-количество победных линий
        x_count = 0 #счетчик крестиков
        for j in range(3): #3-количество клеток в победной линии
            if start_board[win_line[i][j]]=="x":
                x_count+=1
                if x_count == 2: #если 2 клетки в победной линии заняты то надо ее закрывать
                    for k in win_line[i]: #находим пустую клетку в линии
                        if start_board[k]=="~":
                            start_board[k]="x"
                            return start_board
    for i in range(8): #8-количество победных линий
        o_count = 0 #счетчик ноликов
        for j in range(3): #3-количество клеток в победной линии
            if start_board[win_line[i][j]]=="o":
                o_count+=1
                if o_count == 2: #если 2 клетки в победной линии заняты то надо ее закрывать
                    for k in win_line[i]: #находим пустую клетку в линии
                        if start_board[k]=="~":
                            start_board[k]="x"
                            return start_board
    for i in range(4): #4-количество углов
        pos_o = [] #список из индексов ноликов
        for j in range(5): #5-количество клеток в угле
            if start_board[corner[i][j]]=="o":
                pos_o.append(j)
                if len(pos_o)==2:
                    for k in range(len(corner[i])):
                        #если ячейка пустая и находится между ноликами
                        if start_board[corner[i][k]]=="~" and (k in [c for c in range(pos_o[0], pos_o[1]-1)]):
                            start_board[corner[i][k]]="x"
                            return start_board
    #если же все выше не сработало, то нам не важно куда ставить крестик
    for i in range(9):
        if start_board[i]=="~": #первая пустая ячейка
            start_board[i]="x"
            return start_board

def main(start_board):
    #если крестики ходят первыми или нолики первым ходом не пошли на центр
    if start_board.count("o")==1 and start_board[4]=="~" or start_board.count("~")==9:
        start_board[4]="x"
        return start_board
    #случаи когда нолики первые пошли на центр
    elif "".join(start_board) == "~~~~o~~~~":
        start_board[0]="x"
        return start_board
    #если функция main не вывела список, вызывается функция defence_attack
    defence_attack(start_board)

while True:
    s1=input().split()
    s2=input().split() #["~", "~" ,"~"]
    s3=input().split()
    start_board = s1 + s2 + s3 #["~", "~" ,"~", "~", "~" ,"~", "~", "~" ,"~"]
    copy_board=start_board #в итоге не подадобилось
    #Проверка на реальность расклада игры.
    #Кол-во крестиков и ноликов не может отличаться больше чем на 1, тк ходы поочередны.
    #Тк ход крестиков, то их не может быть больше чем ноликов
    if (abs(start_board.count("x")-start_board.count("o"))>=2) or (start_board.count("x")>start_board.count("o")):
        print("Такого расклада не может быть.")
        print()
    #Если расклад реален, то печатается поле с наилучшим ходом для крестика.
    else:
        main(start_board)
        for i in range(0, 7, 3):
            print(f'{start_board[i]} {start_board[i+1]} {start_board[i+2]}')
        print()